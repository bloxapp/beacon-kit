// Code generated by gowrap. DO NOT EDIT.
// template: methods.template
// gowrap: http://github.com/hexdigest/gowrap

package pool

//go:generate gowrap gen -p github.com/bloxapp/beacon-kit -i Client -t methods.template -o methods.go -l ""

import (
	"context"
	"sync"
	"time"

	"github.com/attestantio/go-eth2-client/api"
	apiv1 "github.com/attestantio/go-eth2-client/api/v1"
	"github.com/attestantio/go-eth2-client/spec"
	"github.com/attestantio/go-eth2-client/spec/altair"
	"github.com/attestantio/go-eth2-client/spec/phase0"
	"github.com/bloxapp/beacon-kit"
)

type methods struct {
	defaultClient func() beacon.Client
	callFunc      func(ctx context.Context, callFunc func(context.Context, beacon.Client) error) error
}

type methodCtxKey struct{}

func methodFromContext(ctx context.Context) string {
	method, ok := ctx.Value(methodCtxKey{}).(string)
	if !ok {
		return "<unknown>"
	}
	return method
}

func (m *methods) Address() (s1 string) {
	return m.defaultClient().Address()
}

func (m *methods) AggregateAttestation(ctx context.Context, slot phase0.Slot, attestationDataRoot phase0.Root) (ap1 *phase0.Attestation, err error) {
	ctx = context.WithValue(ctx, methodCtxKey{}, "AggregateAttestation")
	type _resultStruct struct {
		ap1 *phase0.Attestation
		err error
	}
	var _result, _unchecked _resultStruct
	var _mutex sync.Mutex
	_result.err = m.callFunc(ctx, func(ctx context.Context, client beacon.Client) error {
		ap1, err := client.AggregateAttestation(ctx, slot, attestationDataRoot)
		_mutex.Lock()
		defer _mutex.Unlock()
		_unchecked = _resultStruct{ap1, err}
		if err != nil {
			return err
		}
		_result = _unchecked
		return nil
	})
	return _result.ap1, _result.err
}

func (m *methods) AttestationData(ctx context.Context, slot phase0.Slot, committeeIndex phase0.CommitteeIndex) (ap1 *phase0.AttestationData, err error) {
	ctx = context.WithValue(ctx, methodCtxKey{}, "AttestationData")
	type _resultStruct struct {
		ap1 *phase0.AttestationData
		err error
	}
	var _result, _unchecked _resultStruct
	var _mutex sync.Mutex
	_result.err = m.callFunc(ctx, func(ctx context.Context, client beacon.Client) error {
		ap1, err := client.AttestationData(ctx, slot, committeeIndex)
		_mutex.Lock()
		defer _mutex.Unlock()
		_unchecked = _resultStruct{ap1, err}
		if err != nil {
			return err
		}
		_result = _unchecked
		return nil
	})
	return _result.ap1, _result.err
}

func (m *methods) AttesterDuties(ctx context.Context, epoch phase0.Epoch, validatorIndices []phase0.ValidatorIndex) (apa1 []*apiv1.AttesterDuty, err error) {
	ctx = context.WithValue(ctx, methodCtxKey{}, "AttesterDuties")
	type _resultStruct struct {
		apa1 []*apiv1.AttesterDuty
		err  error
	}
	var _result, _unchecked _resultStruct
	var _mutex sync.Mutex
	_result.err = m.callFunc(ctx, func(ctx context.Context, client beacon.Client) error {
		apa1, err := client.AttesterDuties(ctx, epoch, validatorIndices)
		_mutex.Lock()
		defer _mutex.Unlock()
		_unchecked = _resultStruct{apa1, err}
		if err != nil {
			return err
		}
		_result = _unchecked
		return nil
	})
	return _result.apa1, _result.err
}

func (m *methods) BeaconBlockHeader(ctx context.Context, blockID string) (bp1 *apiv1.BeaconBlockHeader, err error) {
	ctx = context.WithValue(ctx, methodCtxKey{}, "BeaconBlockHeader")
	type _resultStruct struct {
		bp1 *apiv1.BeaconBlockHeader
		err error
	}
	var _result, _unchecked _resultStruct
	var _mutex sync.Mutex
	_result.err = m.callFunc(ctx, func(ctx context.Context, client beacon.Client) error {
		bp1, err := client.BeaconBlockHeader(ctx, blockID)
		_mutex.Lock()
		defer _mutex.Unlock()
		_unchecked = _resultStruct{bp1, err}
		if err != nil {
			return err
		}
		_result = _unchecked
		return nil
	})
	return _result.bp1, _result.err
}

func (m *methods) BeaconBlockProposal(ctx context.Context, slot phase0.Slot, randaoReveal phase0.BLSSignature, graffiti []byte) (vp1 *spec.VersionedBeaconBlock, err error) {
	ctx = context.WithValue(ctx, methodCtxKey{}, "BeaconBlockProposal")
	type _resultStruct struct {
		vp1 *spec.VersionedBeaconBlock
		err error
	}
	var _result, _unchecked _resultStruct
	var _mutex sync.Mutex
	_result.err = m.callFunc(ctx, func(ctx context.Context, client beacon.Client) error {
		vp1, err := client.BeaconBlockProposal(ctx, slot, randaoReveal, graffiti)
		_mutex.Lock()
		defer _mutex.Unlock()
		_unchecked = _resultStruct{vp1, err}
		if err != nil {
			return err
		}
		_result = _unchecked
		return nil
	})
	return _result.vp1, _result.err
}

func (m *methods) BeaconBlockRoot(ctx context.Context, blockID string) (rp1 *phase0.Root, err error) {
	ctx = context.WithValue(ctx, methodCtxKey{}, "BeaconBlockRoot")
	type _resultStruct struct {
		rp1 *phase0.Root
		err error
	}
	var _result, _unchecked _resultStruct
	var _mutex sync.Mutex
	_result.err = m.callFunc(ctx, func(ctx context.Context, client beacon.Client) error {
		rp1, err := client.BeaconBlockRoot(ctx, blockID)
		_mutex.Lock()
		defer _mutex.Unlock()
		_unchecked = _resultStruct{rp1, err}
		if err != nil {
			return err
		}
		_result = _unchecked
		return nil
	})
	return _result.rp1, _result.err
}

func (m *methods) BlindedBeaconBlockProposal(ctx context.Context, slot phase0.Slot, randaoReveal phase0.BLSSignature, graffiti []byte) (vp1 *api.VersionedBlindedBeaconBlock, err error) {
	ctx = context.WithValue(ctx, methodCtxKey{}, "BlindedBeaconBlockProposal")
	type _resultStruct struct {
		vp1 *api.VersionedBlindedBeaconBlock
		err error
	}
	var _result, _unchecked _resultStruct
	var _mutex sync.Mutex
	_result.err = m.callFunc(ctx, func(ctx context.Context, client beacon.Client) error {
		vp1, err := client.BlindedBeaconBlockProposal(ctx, slot, randaoReveal, graffiti)
		_mutex.Lock()
		defer _mutex.Unlock()
		_unchecked = _resultStruct{vp1, err}
		if err != nil {
			return err
		}
		_result = _unchecked
		return nil
	})
	return _result.vp1, _result.err
}

func (m *methods) Domain(ctx context.Context, domainType phase0.DomainType, epoch phase0.Epoch) (d1 phase0.Domain, err error) {
	ctx = context.WithValue(ctx, methodCtxKey{}, "Domain")
	type _resultStruct struct {
		d1  phase0.Domain
		err error
	}
	var _result, _unchecked _resultStruct
	var _mutex sync.Mutex
	_result.err = m.callFunc(ctx, func(ctx context.Context, client beacon.Client) error {
		d1, err := client.Domain(ctx, domainType, epoch)
		_mutex.Lock()
		defer _mutex.Unlock()
		_unchecked = _resultStruct{d1, err}
		if err != nil {
			return err
		}
		_result = _unchecked
		return nil
	})
	return _result.d1, _result.err
}

func (m *methods) GenesisTime(ctx context.Context) (t1 time.Time, err error) {
	ctx = context.WithValue(ctx, methodCtxKey{}, "GenesisTime")
	type _resultStruct struct {
		t1  time.Time
		err error
	}
	var _result, _unchecked _resultStruct
	var _mutex sync.Mutex
	_result.err = m.callFunc(ctx, func(ctx context.Context, client beacon.Client) error {
		t1, err := client.GenesisTime(ctx)
		_mutex.Lock()
		defer _mutex.Unlock()
		_unchecked = _resultStruct{t1, err}
		if err != nil {
			return err
		}
		_result = _unchecked
		return nil
	})
	return _result.t1, _result.err
}

func (m *methods) Name() (s1 string) {
	return m.defaultClient().Name()
}

func (m *methods) ProposerDuties(ctx context.Context, epoch phase0.Epoch, validatorIndices []phase0.ValidatorIndex) (ppa1 []*apiv1.ProposerDuty, err error) {
	ctx = context.WithValue(ctx, methodCtxKey{}, "ProposerDuties")
	type _resultStruct struct {
		ppa1 []*apiv1.ProposerDuty
		err  error
	}
	var _result, _unchecked _resultStruct
	var _mutex sync.Mutex
	_result.err = m.callFunc(ctx, func(ctx context.Context, client beacon.Client) error {
		ppa1, err := client.ProposerDuties(ctx, epoch, validatorIndices)
		_mutex.Lock()
		defer _mutex.Unlock()
		_unchecked = _resultStruct{ppa1, err}
		if err != nil {
			return err
		}
		_result = _unchecked
		return nil
	})
	return _result.ppa1, _result.err
}

func (m *methods) SignedBeaconBlock(ctx context.Context, blockID string) (vp1 *spec.VersionedSignedBeaconBlock, err error) {
	ctx = context.WithValue(ctx, methodCtxKey{}, "SignedBeaconBlock")
	type _resultStruct struct {
		vp1 *spec.VersionedSignedBeaconBlock
		err error
	}
	var _result, _unchecked _resultStruct
	var _mutex sync.Mutex
	_result.err = m.callFunc(ctx, func(ctx context.Context, client beacon.Client) error {
		vp1, err := client.SignedBeaconBlock(ctx, blockID)
		_mutex.Lock()
		defer _mutex.Unlock()
		_unchecked = _resultStruct{vp1, err}
		if err != nil {
			return err
		}
		_result = _unchecked
		return nil
	})
	return _result.vp1, _result.err
}

func (m *methods) Spec(ctx context.Context) (m1 map[string]interface{}, err error) {
	ctx = context.WithValue(ctx, methodCtxKey{}, "Spec")
	type _resultStruct struct {
		m1  map[string]interface{}
		err error
	}
	var _result, _unchecked _resultStruct
	var _mutex sync.Mutex
	_result.err = m.callFunc(ctx, func(ctx context.Context, client beacon.Client) error {
		m1, err := client.Spec(ctx)
		_mutex.Lock()
		defer _mutex.Unlock()
		_unchecked = _resultStruct{m1, err}
		if err != nil {
			return err
		}
		_result = _unchecked
		return nil
	})
	return _result.m1, _result.err
}

func (m *methods) SubmitAggregateAttestations(ctx context.Context, aggregateAndProofs []*phase0.SignedAggregateAndProof) (err error) {
	ctx = context.WithValue(ctx, methodCtxKey{}, "SubmitAggregateAttestations")
	type _resultStruct struct {
		err error
	}
	var _result, _unchecked _resultStruct
	var _mutex sync.Mutex
	_result.err = m.callFunc(ctx, func(ctx context.Context, client beacon.Client) error {
		err := client.SubmitAggregateAttestations(ctx, aggregateAndProofs)
		_mutex.Lock()
		defer _mutex.Unlock()
		_unchecked = _resultStruct{err}
		if err != nil {
			return err
		}
		_result = _unchecked
		return nil
	})
	return _result.err
}

func (m *methods) SubmitAttestations(ctx context.Context, attestations []*phase0.Attestation) (err error) {
	ctx = context.WithValue(ctx, methodCtxKey{}, "SubmitAttestations")
	type _resultStruct struct {
		err error
	}
	var _result, _unchecked _resultStruct
	var _mutex sync.Mutex
	_result.err = m.callFunc(ctx, func(ctx context.Context, client beacon.Client) error {
		err := client.SubmitAttestations(ctx, attestations)
		_mutex.Lock()
		defer _mutex.Unlock()
		_unchecked = _resultStruct{err}
		if err != nil {
			return err
		}
		_result = _unchecked
		return nil
	})
	return _result.err
}

func (m *methods) SubmitBeaconBlock(ctx context.Context, block *spec.VersionedSignedBeaconBlock) (err error) {
	ctx = context.WithValue(ctx, methodCtxKey{}, "SubmitBeaconBlock")
	type _resultStruct struct {
		err error
	}
	var _result, _unchecked _resultStruct
	var _mutex sync.Mutex
	_result.err = m.callFunc(ctx, func(ctx context.Context, client beacon.Client) error {
		err := client.SubmitBeaconBlock(ctx, block)
		_mutex.Lock()
		defer _mutex.Unlock()
		_unchecked = _resultStruct{err}
		if err != nil {
			return err
		}
		_result = _unchecked
		return nil
	})
	return _result.err
}

func (m *methods) SubmitBeaconCommitteeSubscriptions(ctx context.Context, subscriptions []*apiv1.BeaconCommitteeSubscription) (err error) {
	ctx = context.WithValue(ctx, methodCtxKey{}, "SubmitBeaconCommitteeSubscriptions")
	type _resultStruct struct {
		err error
	}
	var _result, _unchecked _resultStruct
	var _mutex sync.Mutex
	_result.err = m.callFunc(ctx, func(ctx context.Context, client beacon.Client) error {
		err := client.SubmitBeaconCommitteeSubscriptions(ctx, subscriptions)
		_mutex.Lock()
		defer _mutex.Unlock()
		_unchecked = _resultStruct{err}
		if err != nil {
			return err
		}
		_result = _unchecked
		return nil
	})
	return _result.err
}

func (m *methods) SubmitBlindedBeaconBlock(ctx context.Context, block *api.VersionedSignedBlindedBeaconBlock) (err error) {
	ctx = context.WithValue(ctx, methodCtxKey{}, "SubmitBlindedBeaconBlock")
	type _resultStruct struct {
		err error
	}
	var _result, _unchecked _resultStruct
	var _mutex sync.Mutex
	_result.err = m.callFunc(ctx, func(ctx context.Context, client beacon.Client) error {
		err := client.SubmitBlindedBeaconBlock(ctx, block)
		_mutex.Lock()
		defer _mutex.Unlock()
		_unchecked = _resultStruct{err}
		if err != nil {
			return err
		}
		_result = _unchecked
		return nil
	})
	return _result.err
}

func (m *methods) SubmitProposalPreparations(ctx context.Context, preparations []*apiv1.ProposalPreparation) (err error) {
	ctx = context.WithValue(ctx, methodCtxKey{}, "SubmitProposalPreparations")
	type _resultStruct struct {
		err error
	}
	var _result, _unchecked _resultStruct
	var _mutex sync.Mutex
	_result.err = m.callFunc(ctx, func(ctx context.Context, client beacon.Client) error {
		err := client.SubmitProposalPreparations(ctx, preparations)
		_mutex.Lock()
		defer _mutex.Unlock()
		_unchecked = _resultStruct{err}
		if err != nil {
			return err
		}
		_result = _unchecked
		return nil
	})
	return _result.err
}

func (m *methods) SubmitSyncCommitteeContributions(ctx context.Context, contributionAndProofs []*altair.SignedContributionAndProof) (err error) {
	ctx = context.WithValue(ctx, methodCtxKey{}, "SubmitSyncCommitteeContributions")
	type _resultStruct struct {
		err error
	}
	var _result, _unchecked _resultStruct
	var _mutex sync.Mutex
	_result.err = m.callFunc(ctx, func(ctx context.Context, client beacon.Client) error {
		err := client.SubmitSyncCommitteeContributions(ctx, contributionAndProofs)
		_mutex.Lock()
		defer _mutex.Unlock()
		_unchecked = _resultStruct{err}
		if err != nil {
			return err
		}
		_result = _unchecked
		return nil
	})
	return _result.err
}

func (m *methods) SubmitSyncCommitteeMessages(ctx context.Context, messages []*altair.SyncCommitteeMessage) (err error) {
	ctx = context.WithValue(ctx, methodCtxKey{}, "SubmitSyncCommitteeMessages")
	type _resultStruct struct {
		err error
	}
	var _result, _unchecked _resultStruct
	var _mutex sync.Mutex
	_result.err = m.callFunc(ctx, func(ctx context.Context, client beacon.Client) error {
		err := client.SubmitSyncCommitteeMessages(ctx, messages)
		_mutex.Lock()
		defer _mutex.Unlock()
		_unchecked = _resultStruct{err}
		if err != nil {
			return err
		}
		_result = _unchecked
		return nil
	})
	return _result.err
}

func (m *methods) SubmitSyncCommitteeSubscriptions(ctx context.Context, subscriptions []*apiv1.SyncCommitteeSubscription) (err error) {
	ctx = context.WithValue(ctx, methodCtxKey{}, "SubmitSyncCommitteeSubscriptions")
	type _resultStruct struct {
		err error
	}
	var _result, _unchecked _resultStruct
	var _mutex sync.Mutex
	_result.err = m.callFunc(ctx, func(ctx context.Context, client beacon.Client) error {
		err := client.SubmitSyncCommitteeSubscriptions(ctx, subscriptions)
		_mutex.Lock()
		defer _mutex.Unlock()
		_unchecked = _resultStruct{err}
		if err != nil {
			return err
		}
		_result = _unchecked
		return nil
	})
	return _result.err
}

func (m *methods) SubmitValidatorRegistrations(ctx context.Context, registrations []*api.VersionedSignedValidatorRegistration) (err error) {
	ctx = context.WithValue(ctx, methodCtxKey{}, "SubmitValidatorRegistrations")
	type _resultStruct struct {
		err error
	}
	var _result, _unchecked _resultStruct
	var _mutex sync.Mutex
	_result.err = m.callFunc(ctx, func(ctx context.Context, client beacon.Client) error {
		err := client.SubmitValidatorRegistrations(ctx, registrations)
		_mutex.Lock()
		defer _mutex.Unlock()
		_unchecked = _resultStruct{err}
		if err != nil {
			return err
		}
		_result = _unchecked
		return nil
	})
	return _result.err
}

func (m *methods) SyncCommitteeContribution(ctx context.Context, slot phase0.Slot, subcommitteeIndex uint64, beaconBlockRoot phase0.Root) (sp1 *altair.SyncCommitteeContribution, err error) {
	ctx = context.WithValue(ctx, methodCtxKey{}, "SyncCommitteeContribution")
	type _resultStruct struct {
		sp1 *altair.SyncCommitteeContribution
		err error
	}
	var _result, _unchecked _resultStruct
	var _mutex sync.Mutex
	_result.err = m.callFunc(ctx, func(ctx context.Context, client beacon.Client) error {
		sp1, err := client.SyncCommitteeContribution(ctx, slot, subcommitteeIndex, beaconBlockRoot)
		_mutex.Lock()
		defer _mutex.Unlock()
		_unchecked = _resultStruct{sp1, err}
		if err != nil {
			return err
		}
		_result = _unchecked
		return nil
	})
	return _result.sp1, _result.err
}

func (m *methods) SyncCommitteeDuties(ctx context.Context, epoch phase0.Epoch, validatorIndices []phase0.ValidatorIndex) (spa1 []*apiv1.SyncCommitteeDuty, err error) {
	ctx = context.WithValue(ctx, methodCtxKey{}, "SyncCommitteeDuties")
	type _resultStruct struct {
		spa1 []*apiv1.SyncCommitteeDuty
		err  error
	}
	var _result, _unchecked _resultStruct
	var _mutex sync.Mutex
	_result.err = m.callFunc(ctx, func(ctx context.Context, client beacon.Client) error {
		spa1, err := client.SyncCommitteeDuties(ctx, epoch, validatorIndices)
		_mutex.Lock()
		defer _mutex.Unlock()
		_unchecked = _resultStruct{spa1, err}
		if err != nil {
			return err
		}
		_result = _unchecked
		return nil
	})
	return _result.spa1, _result.err
}

func (m *methods) Validators(ctx context.Context, stateID string, validatorIndices []phase0.ValidatorIndex) (m1 map[phase0.ValidatorIndex]*apiv1.Validator, err error) {
	ctx = context.WithValue(ctx, methodCtxKey{}, "Validators")
	type _resultStruct struct {
		m1  map[phase0.ValidatorIndex]*apiv1.Validator
		err error
	}
	var _result, _unchecked _resultStruct
	var _mutex sync.Mutex
	_result.err = m.callFunc(ctx, func(ctx context.Context, client beacon.Client) error {
		m1, err := client.Validators(ctx, stateID, validatorIndices)
		_mutex.Lock()
		defer _mutex.Unlock()
		_unchecked = _resultStruct{m1, err}
		if err != nil {
			return err
		}
		_result = _unchecked
		return nil
	})
	return _result.m1, _result.err
}

func (m *methods) ValidatorsByPubKey(ctx context.Context, stateID string, validatorPubKeys []phase0.BLSPubKey) (m1 map[phase0.ValidatorIndex]*apiv1.Validator, err error) {
	ctx = context.WithValue(ctx, methodCtxKey{}, "ValidatorsByPubKey")
	type _resultStruct struct {
		m1  map[phase0.ValidatorIndex]*apiv1.Validator
		err error
	}
	var _result, _unchecked _resultStruct
	var _mutex sync.Mutex
	_result.err = m.callFunc(ctx, func(ctx context.Context, client beacon.Client) error {
		m1, err := client.ValidatorsByPubKey(ctx, stateID, validatorPubKeys)
		_mutex.Lock()
		defer _mutex.Unlock()
		_unchecked = _resultStruct{m1, err}
		if err != nil {
			return err
		}
		_result = _unchecked
		return nil
	})
	return _result.m1, _result.err
}
