// Code generated by mockery v2.16.0. DO NOT EDIT.

package mocks

import (
	api "github.com/attestantio/go-eth2-client/api"
	altair "github.com/attestantio/go-eth2-client/spec/altair"

	context "context"

	mock "github.com/stretchr/testify/mock"

	phase0 "github.com/attestantio/go-eth2-client/spec/phase0"

	spec "github.com/attestantio/go-eth2-client/spec"

	time "time"

	v1 "github.com/attestantio/go-eth2-client/api/v1"
)

// Client is an autogenerated mock type for the Client type
type Client struct {
	mock.Mock
}

// Address provides a mock function with given fields:
func (_m *Client) Address() string {
	ret := _m.Called()

	var r0 string
	if rf, ok := ret.Get(0).(func() string); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(string)
	}

	return r0
}

// AggregateAttestation provides a mock function with given fields: ctx, slot, attestationDataRoot
func (_m *Client) AggregateAttestation(ctx context.Context, slot phase0.Slot, attestationDataRoot phase0.Root) (*phase0.Attestation, error) {
	ret := _m.Called(ctx, slot, attestationDataRoot)

	var r0 *phase0.Attestation
	if rf, ok := ret.Get(0).(func(context.Context, phase0.Slot, phase0.Root) *phase0.Attestation); ok {
		r0 = rf(ctx, slot, attestationDataRoot)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*phase0.Attestation)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, phase0.Slot, phase0.Root) error); ok {
		r1 = rf(ctx, slot, attestationDataRoot)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// AttestationData provides a mock function with given fields: ctx, slot, committeeIndex
func (_m *Client) AttestationData(ctx context.Context, slot phase0.Slot, committeeIndex phase0.CommitteeIndex) (*phase0.AttestationData, error) {
	ret := _m.Called(ctx, slot, committeeIndex)

	var r0 *phase0.AttestationData
	if rf, ok := ret.Get(0).(func(context.Context, phase0.Slot, phase0.CommitteeIndex) *phase0.AttestationData); ok {
		r0 = rf(ctx, slot, committeeIndex)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*phase0.AttestationData)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, phase0.Slot, phase0.CommitteeIndex) error); ok {
		r1 = rf(ctx, slot, committeeIndex)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// AttesterDuties provides a mock function with given fields: ctx, epoch, validatorIndices
func (_m *Client) AttesterDuties(ctx context.Context, epoch phase0.Epoch, validatorIndices []phase0.ValidatorIndex) ([]*v1.AttesterDuty, error) {
	ret := _m.Called(ctx, epoch, validatorIndices)

	var r0 []*v1.AttesterDuty
	if rf, ok := ret.Get(0).(func(context.Context, phase0.Epoch, []phase0.ValidatorIndex) []*v1.AttesterDuty); ok {
		r0 = rf(ctx, epoch, validatorIndices)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*v1.AttesterDuty)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, phase0.Epoch, []phase0.ValidatorIndex) error); ok {
		r1 = rf(ctx, epoch, validatorIndices)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// BeaconBlockHeader provides a mock function with given fields: ctx, blockID
func (_m *Client) BeaconBlockHeader(ctx context.Context, blockID string) (*v1.BeaconBlockHeader, error) {
	ret := _m.Called(ctx, blockID)

	var r0 *v1.BeaconBlockHeader
	if rf, ok := ret.Get(0).(func(context.Context, string) *v1.BeaconBlockHeader); ok {
		r0 = rf(ctx, blockID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*v1.BeaconBlockHeader)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = rf(ctx, blockID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// BeaconBlockProposal provides a mock function with given fields: ctx, slot, randaoReveal, graffiti
func (_m *Client) BeaconBlockProposal(ctx context.Context, slot phase0.Slot, randaoReveal phase0.BLSSignature, graffiti []byte) (*spec.VersionedBeaconBlock, error) {
	ret := _m.Called(ctx, slot, randaoReveal, graffiti)

	var r0 *spec.VersionedBeaconBlock
	if rf, ok := ret.Get(0).(func(context.Context, phase0.Slot, phase0.BLSSignature, []byte) *spec.VersionedBeaconBlock); ok {
		r0 = rf(ctx, slot, randaoReveal, graffiti)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*spec.VersionedBeaconBlock)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, phase0.Slot, phase0.BLSSignature, []byte) error); ok {
		r1 = rf(ctx, slot, randaoReveal, graffiti)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// BeaconBlockRoot provides a mock function with given fields: ctx, blockID
func (_m *Client) BeaconBlockRoot(ctx context.Context, blockID string) (*phase0.Root, error) {
	ret := _m.Called(ctx, blockID)

	var r0 *phase0.Root
	if rf, ok := ret.Get(0).(func(context.Context, string) *phase0.Root); ok {
		r0 = rf(ctx, blockID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*phase0.Root)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = rf(ctx, blockID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// BlindedBeaconBlockProposal provides a mock function with given fields: ctx, slot, randaoReveal, graffiti
func (_m *Client) BlindedBeaconBlockProposal(ctx context.Context, slot phase0.Slot, randaoReveal phase0.BLSSignature, graffiti []byte) (*api.VersionedBlindedBeaconBlock, error) {
	ret := _m.Called(ctx, slot, randaoReveal, graffiti)

	var r0 *api.VersionedBlindedBeaconBlock
	if rf, ok := ret.Get(0).(func(context.Context, phase0.Slot, phase0.BLSSignature, []byte) *api.VersionedBlindedBeaconBlock); ok {
		r0 = rf(ctx, slot, randaoReveal, graffiti)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*api.VersionedBlindedBeaconBlock)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, phase0.Slot, phase0.BLSSignature, []byte) error); ok {
		r1 = rf(ctx, slot, randaoReveal, graffiti)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Domain provides a mock function with given fields: ctx, domainType, epoch
func (_m *Client) Domain(ctx context.Context, domainType phase0.DomainType, epoch phase0.Epoch) (phase0.Domain, error) {
	ret := _m.Called(ctx, domainType, epoch)

	var r0 phase0.Domain
	if rf, ok := ret.Get(0).(func(context.Context, phase0.DomainType, phase0.Epoch) phase0.Domain); ok {
		r0 = rf(ctx, domainType, epoch)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(phase0.Domain)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, phase0.DomainType, phase0.Epoch) error); ok {
		r1 = rf(ctx, domainType, epoch)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GenesisTime provides a mock function with given fields: ctx
func (_m *Client) GenesisTime(ctx context.Context) (time.Time, error) {
	ret := _m.Called(ctx)

	var r0 time.Time
	if rf, ok := ret.Get(0).(func(context.Context) time.Time); ok {
		r0 = rf(ctx)
	} else {
		r0 = ret.Get(0).(time.Time)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = rf(ctx)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Name provides a mock function with given fields:
func (_m *Client) Name() string {
	ret := _m.Called()

	var r0 string
	if rf, ok := ret.Get(0).(func() string); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(string)
	}

	return r0
}

// ProposerDuties provides a mock function with given fields: ctx, epoch, validatorIndices
func (_m *Client) ProposerDuties(ctx context.Context, epoch phase0.Epoch, validatorIndices []phase0.ValidatorIndex) ([]*v1.ProposerDuty, error) {
	ret := _m.Called(ctx, epoch, validatorIndices)

	var r0 []*v1.ProposerDuty
	if rf, ok := ret.Get(0).(func(context.Context, phase0.Epoch, []phase0.ValidatorIndex) []*v1.ProposerDuty); ok {
		r0 = rf(ctx, epoch, validatorIndices)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*v1.ProposerDuty)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, phase0.Epoch, []phase0.ValidatorIndex) error); ok {
		r1 = rf(ctx, epoch, validatorIndices)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// SignedBeaconBlock provides a mock function with given fields: ctx, blockID
func (_m *Client) SignedBeaconBlock(ctx context.Context, blockID string) (*spec.VersionedSignedBeaconBlock, error) {
	ret := _m.Called(ctx, blockID)

	var r0 *spec.VersionedSignedBeaconBlock
	if rf, ok := ret.Get(0).(func(context.Context, string) *spec.VersionedSignedBeaconBlock); ok {
		r0 = rf(ctx, blockID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*spec.VersionedSignedBeaconBlock)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = rf(ctx, blockID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Spec provides a mock function with given fields: ctx
func (_m *Client) Spec(ctx context.Context) (map[string]interface{}, error) {
	ret := _m.Called(ctx)

	var r0 map[string]interface{}
	if rf, ok := ret.Get(0).(func(context.Context) map[string]interface{}); ok {
		r0 = rf(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(map[string]interface{})
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = rf(ctx)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// SubmitAggregateAttestations provides a mock function with given fields: ctx, aggregateAndProofs
func (_m *Client) SubmitAggregateAttestations(ctx context.Context, aggregateAndProofs []*phase0.SignedAggregateAndProof) error {
	ret := _m.Called(ctx, aggregateAndProofs)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, []*phase0.SignedAggregateAndProof) error); ok {
		r0 = rf(ctx, aggregateAndProofs)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// SubmitAttestations provides a mock function with given fields: ctx, attestations
func (_m *Client) SubmitAttestations(ctx context.Context, attestations []*phase0.Attestation) error {
	ret := _m.Called(ctx, attestations)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, []*phase0.Attestation) error); ok {
		r0 = rf(ctx, attestations)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// SubmitBeaconBlock provides a mock function with given fields: ctx, block
func (_m *Client) SubmitBeaconBlock(ctx context.Context, block *spec.VersionedSignedBeaconBlock) error {
	ret := _m.Called(ctx, block)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, *spec.VersionedSignedBeaconBlock) error); ok {
		r0 = rf(ctx, block)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// SubmitBeaconCommitteeSubscriptions provides a mock function with given fields: ctx, subscriptions
func (_m *Client) SubmitBeaconCommitteeSubscriptions(ctx context.Context, subscriptions []*v1.BeaconCommitteeSubscription) error {
	ret := _m.Called(ctx, subscriptions)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, []*v1.BeaconCommitteeSubscription) error); ok {
		r0 = rf(ctx, subscriptions)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// SubmitBlindedBeaconBlock provides a mock function with given fields: ctx, block
func (_m *Client) SubmitBlindedBeaconBlock(ctx context.Context, block *api.VersionedSignedBlindedBeaconBlock) error {
	ret := _m.Called(ctx, block)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, *api.VersionedSignedBlindedBeaconBlock) error); ok {
		r0 = rf(ctx, block)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// SubmitProposalPreparations provides a mock function with given fields: ctx, preparations
func (_m *Client) SubmitProposalPreparations(ctx context.Context, preparations []*v1.ProposalPreparation) error {
	ret := _m.Called(ctx, preparations)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, []*v1.ProposalPreparation) error); ok {
		r0 = rf(ctx, preparations)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// SubmitSyncCommitteeContributions provides a mock function with given fields: ctx, contributionAndProofs
func (_m *Client) SubmitSyncCommitteeContributions(ctx context.Context, contributionAndProofs []*altair.SignedContributionAndProof) error {
	ret := _m.Called(ctx, contributionAndProofs)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, []*altair.SignedContributionAndProof) error); ok {
		r0 = rf(ctx, contributionAndProofs)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// SubmitSyncCommitteeMessages provides a mock function with given fields: ctx, messages
func (_m *Client) SubmitSyncCommitteeMessages(ctx context.Context, messages []*altair.SyncCommitteeMessage) error {
	ret := _m.Called(ctx, messages)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, []*altair.SyncCommitteeMessage) error); ok {
		r0 = rf(ctx, messages)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// SubmitSyncCommitteeSubscriptions provides a mock function with given fields: ctx, subscriptions
func (_m *Client) SubmitSyncCommitteeSubscriptions(ctx context.Context, subscriptions []*v1.SyncCommitteeSubscription) error {
	ret := _m.Called(ctx, subscriptions)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, []*v1.SyncCommitteeSubscription) error); ok {
		r0 = rf(ctx, subscriptions)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// SubmitValidatorRegistrations provides a mock function with given fields: ctx, registrations
func (_m *Client) SubmitValidatorRegistrations(ctx context.Context, registrations []*api.VersionedSignedValidatorRegistration) error {
	ret := _m.Called(ctx, registrations)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, []*api.VersionedSignedValidatorRegistration) error); ok {
		r0 = rf(ctx, registrations)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// SyncCommitteeContribution provides a mock function with given fields: ctx, slot, subcommitteeIndex, beaconBlockRoot
func (_m *Client) SyncCommitteeContribution(ctx context.Context, slot phase0.Slot, subcommitteeIndex uint64, beaconBlockRoot phase0.Root) (*altair.SyncCommitteeContribution, error) {
	ret := _m.Called(ctx, slot, subcommitteeIndex, beaconBlockRoot)

	var r0 *altair.SyncCommitteeContribution
	if rf, ok := ret.Get(0).(func(context.Context, phase0.Slot, uint64, phase0.Root) *altair.SyncCommitteeContribution); ok {
		r0 = rf(ctx, slot, subcommitteeIndex, beaconBlockRoot)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*altair.SyncCommitteeContribution)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, phase0.Slot, uint64, phase0.Root) error); ok {
		r1 = rf(ctx, slot, subcommitteeIndex, beaconBlockRoot)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// SyncCommitteeDuties provides a mock function with given fields: ctx, epoch, validatorIndices
func (_m *Client) SyncCommitteeDuties(ctx context.Context, epoch phase0.Epoch, validatorIndices []phase0.ValidatorIndex) ([]*v1.SyncCommitteeDuty, error) {
	ret := _m.Called(ctx, epoch, validatorIndices)

	var r0 []*v1.SyncCommitteeDuty
	if rf, ok := ret.Get(0).(func(context.Context, phase0.Epoch, []phase0.ValidatorIndex) []*v1.SyncCommitteeDuty); ok {
		r0 = rf(ctx, epoch, validatorIndices)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*v1.SyncCommitteeDuty)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, phase0.Epoch, []phase0.ValidatorIndex) error); ok {
		r1 = rf(ctx, epoch, validatorIndices)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Validators provides a mock function with given fields: ctx, stateID, validatorIndices
func (_m *Client) Validators(ctx context.Context, stateID string, validatorIndices []phase0.ValidatorIndex) (map[phase0.ValidatorIndex]*v1.Validator, error) {
	ret := _m.Called(ctx, stateID, validatorIndices)

	var r0 map[phase0.ValidatorIndex]*v1.Validator
	if rf, ok := ret.Get(0).(func(context.Context, string, []phase0.ValidatorIndex) map[phase0.ValidatorIndex]*v1.Validator); ok {
		r0 = rf(ctx, stateID, validatorIndices)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(map[phase0.ValidatorIndex]*v1.Validator)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, string, []phase0.ValidatorIndex) error); ok {
		r1 = rf(ctx, stateID, validatorIndices)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ValidatorsByPubKey provides a mock function with given fields: ctx, stateID, validatorPubKeys
func (_m *Client) ValidatorsByPubKey(ctx context.Context, stateID string, validatorPubKeys []phase0.BLSPubKey) (map[phase0.ValidatorIndex]*v1.Validator, error) {
	ret := _m.Called(ctx, stateID, validatorPubKeys)

	var r0 map[phase0.ValidatorIndex]*v1.Validator
	if rf, ok := ret.Get(0).(func(context.Context, string, []phase0.BLSPubKey) map[phase0.ValidatorIndex]*v1.Validator); ok {
		r0 = rf(ctx, stateID, validatorPubKeys)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(map[phase0.ValidatorIndex]*v1.Validator)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(context.Context, string, []phase0.BLSPubKey) error); ok {
		r1 = rf(ctx, stateID, validatorPubKeys)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

type mockConstructorTestingTNewClient interface {
	mock.TestingT
	Cleanup(func())
}

// NewClient creates a new instance of Client. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
func NewClient(t mockConstructorTestingTNewClient) *Client {
	mock := &Client{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
