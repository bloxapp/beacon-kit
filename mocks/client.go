// Code generated by mockery v2.40.1. DO NOT EDIT.

package mocks

import (
	api "github.com/attestantio/go-eth2-client/api"
	altair "github.com/attestantio/go-eth2-client/spec/altair"

	client "github.com/attestantio/go-eth2-client"

	context "context"

	mock "github.com/stretchr/testify/mock"

	phase0 "github.com/attestantio/go-eth2-client/spec/phase0"

	spec "github.com/attestantio/go-eth2-client/spec"

	v1 "github.com/attestantio/go-eth2-client/api/v1"
)

// Client is an autogenerated mock type for the Client type
type Client struct {
	mock.Mock
}

// Address provides a mock function with given fields:
func (_m *Client) Address() string {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for Address")
	}

	var r0 string
	if rf, ok := ret.Get(0).(func() string); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(string)
	}

	return r0
}

// AggregateAttestation provides a mock function with given fields: ctx, slot, attestationDataRoot
func (_m *Client) AggregateAttestation(ctx context.Context, slot phase0.Slot, attestationDataRoot phase0.Root) (*phase0.Attestation, error) {
	ret := _m.Called(ctx, slot, attestationDataRoot)

	if len(ret) == 0 {
		panic("no return value specified for AggregateAttestation")
	}

	var r0 *phase0.Attestation
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, phase0.Slot, phase0.Root) (*phase0.Attestation, error)); ok {
		return rf(ctx, slot, attestationDataRoot)
	}
	if rf, ok := ret.Get(0).(func(context.Context, phase0.Slot, phase0.Root) *phase0.Attestation); ok {
		r0 = rf(ctx, slot, attestationDataRoot)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*phase0.Attestation)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, phase0.Slot, phase0.Root) error); ok {
		r1 = rf(ctx, slot, attestationDataRoot)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// AttestationData provides a mock function with given fields: ctx, slot, committeeIndex
func (_m *Client) AttestationData(ctx context.Context, slot phase0.Slot, committeeIndex phase0.CommitteeIndex) (*phase0.AttestationData, error) {
	ret := _m.Called(ctx, slot, committeeIndex)

	if len(ret) == 0 {
		panic("no return value specified for AttestationData")
	}

	var r0 *phase0.AttestationData
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, phase0.Slot, phase0.CommitteeIndex) (*phase0.AttestationData, error)); ok {
		return rf(ctx, slot, committeeIndex)
	}
	if rf, ok := ret.Get(0).(func(context.Context, phase0.Slot, phase0.CommitteeIndex) *phase0.AttestationData); ok {
		r0 = rf(ctx, slot, committeeIndex)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*phase0.AttestationData)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, phase0.Slot, phase0.CommitteeIndex) error); ok {
		r1 = rf(ctx, slot, committeeIndex)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// AttesterDuties provides a mock function with given fields: ctx, epoch, indices
func (_m *Client) AttesterDuties(ctx context.Context, epoch phase0.Epoch, indices []phase0.ValidatorIndex) ([]*v1.AttesterDuty, error) {
	ret := _m.Called(ctx, epoch, indices)

	if len(ret) == 0 {
		panic("no return value specified for AttesterDuties")
	}

	var r0 []*v1.AttesterDuty
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, phase0.Epoch, []phase0.ValidatorIndex) ([]*v1.AttesterDuty, error)); ok {
		return rf(ctx, epoch, indices)
	}
	if rf, ok := ret.Get(0).(func(context.Context, phase0.Epoch, []phase0.ValidatorIndex) []*v1.AttesterDuty); ok {
		r0 = rf(ctx, epoch, indices)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*v1.AttesterDuty)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, phase0.Epoch, []phase0.ValidatorIndex) error); ok {
		r1 = rf(ctx, epoch, indices)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// BeaconBlockHeader provides a mock function with given fields: ctx, blockID
func (_m *Client) BeaconBlockHeader(ctx context.Context, blockID string) (*v1.BeaconBlockHeader, error) {
	ret := _m.Called(ctx, blockID)

	if len(ret) == 0 {
		panic("no return value specified for BeaconBlockHeader")
	}

	var r0 *v1.BeaconBlockHeader
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string) (*v1.BeaconBlockHeader, error)); ok {
		return rf(ctx, blockID)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string) *v1.BeaconBlockHeader); ok {
		r0 = rf(ctx, blockID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*v1.BeaconBlockHeader)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = rf(ctx, blockID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// BeaconBlockRoot provides a mock function with given fields: ctx, blockID
func (_m *Client) BeaconBlockRoot(ctx context.Context, blockID string) (*phase0.Root, error) {
	ret := _m.Called(ctx, blockID)

	if len(ret) == 0 {
		panic("no return value specified for BeaconBlockRoot")
	}

	var r0 *phase0.Root
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string) (*phase0.Root, error)); ok {
		return rf(ctx, blockID)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string) *phase0.Root); ok {
		r0 = rf(ctx, blockID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*phase0.Root)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = rf(ctx, blockID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// BlindedProposal provides a mock function with given fields: ctx, slot, randaoReveal, graffiti
func (_m *Client) BlindedProposal(ctx context.Context, slot phase0.Slot, randaoReveal phase0.BLSSignature, graffiti [32]byte) (*api.VersionedBlindedProposal, error) {
	ret := _m.Called(ctx, slot, randaoReveal, graffiti)

	if len(ret) == 0 {
		panic("no return value specified for BlindedProposal")
	}

	var r0 *api.VersionedBlindedProposal
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, phase0.Slot, phase0.BLSSignature, [32]byte) (*api.VersionedBlindedProposal, error)); ok {
		return rf(ctx, slot, randaoReveal, graffiti)
	}
	if rf, ok := ret.Get(0).(func(context.Context, phase0.Slot, phase0.BLSSignature, [32]byte) *api.VersionedBlindedProposal); ok {
		r0 = rf(ctx, slot, randaoReveal, graffiti)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*api.VersionedBlindedProposal)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, phase0.Slot, phase0.BLSSignature, [32]byte) error); ok {
		r1 = rf(ctx, slot, randaoReveal, graffiti)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Domain provides a mock function with given fields: ctx, domainType, epoch
func (_m *Client) Domain(ctx context.Context, domainType phase0.DomainType, epoch phase0.Epoch) (phase0.Domain, error) {
	ret := _m.Called(ctx, domainType, epoch)

	if len(ret) == 0 {
		panic("no return value specified for Domain")
	}

	var r0 phase0.Domain
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, phase0.DomainType, phase0.Epoch) (phase0.Domain, error)); ok {
		return rf(ctx, domainType, epoch)
	}
	if rf, ok := ret.Get(0).(func(context.Context, phase0.DomainType, phase0.Epoch) phase0.Domain); ok {
		r0 = rf(ctx, domainType, epoch)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(phase0.Domain)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, phase0.DomainType, phase0.Epoch) error); ok {
		r1 = rf(ctx, domainType, epoch)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Events provides a mock function with given fields: ctx, topics, handler
func (_m *Client) Events(ctx context.Context, topics []string, handler client.EventHandlerFunc) error {
	ret := _m.Called(ctx, topics, handler)

	if len(ret) == 0 {
		panic("no return value specified for Events")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, []string, client.EventHandlerFunc) error); ok {
		r0 = rf(ctx, topics, handler)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Genesis provides a mock function with given fields: ctx
func (_m *Client) Genesis(ctx context.Context) (*v1.Genesis, error) {
	ret := _m.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for Genesis")
	}

	var r0 *v1.Genesis
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context) (*v1.Genesis, error)); ok {
		return rf(ctx)
	}
	if rf, ok := ret.Get(0).(func(context.Context) *v1.Genesis); ok {
		r0 = rf(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*v1.Genesis)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = rf(ctx)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Name provides a mock function with given fields:
func (_m *Client) Name() string {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for Name")
	}

	var r0 string
	if rf, ok := ret.Get(0).(func() string); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(string)
	}

	return r0
}

// Proposal provides a mock function with given fields: ctx, slot, randaoReveal, graffiti
func (_m *Client) Proposal(ctx context.Context, slot phase0.Slot, randaoReveal phase0.BLSSignature, graffiti [32]byte) (*api.VersionedProposal, error) {
	ret := _m.Called(ctx, slot, randaoReveal, graffiti)

	if len(ret) == 0 {
		panic("no return value specified for Proposal")
	}

	var r0 *api.VersionedProposal
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, phase0.Slot, phase0.BLSSignature, [32]byte) (*api.VersionedProposal, error)); ok {
		return rf(ctx, slot, randaoReveal, graffiti)
	}
	if rf, ok := ret.Get(0).(func(context.Context, phase0.Slot, phase0.BLSSignature, [32]byte) *api.VersionedProposal); ok {
		r0 = rf(ctx, slot, randaoReveal, graffiti)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*api.VersionedProposal)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, phase0.Slot, phase0.BLSSignature, [32]byte) error); ok {
		r1 = rf(ctx, slot, randaoReveal, graffiti)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ProposerDuties provides a mock function with given fields: ctx, epoch, indices
func (_m *Client) ProposerDuties(ctx context.Context, epoch phase0.Epoch, indices []phase0.ValidatorIndex) ([]*v1.ProposerDuty, error) {
	ret := _m.Called(ctx, epoch, indices)

	if len(ret) == 0 {
		panic("no return value specified for ProposerDuties")
	}

	var r0 []*v1.ProposerDuty
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, phase0.Epoch, []phase0.ValidatorIndex) ([]*v1.ProposerDuty, error)); ok {
		return rf(ctx, epoch, indices)
	}
	if rf, ok := ret.Get(0).(func(context.Context, phase0.Epoch, []phase0.ValidatorIndex) []*v1.ProposerDuty); ok {
		r0 = rf(ctx, epoch, indices)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*v1.ProposerDuty)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, phase0.Epoch, []phase0.ValidatorIndex) error); ok {
		r1 = rf(ctx, epoch, indices)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// SignedBeaconBlock provides a mock function with given fields: ctx, blockID
func (_m *Client) SignedBeaconBlock(ctx context.Context, blockID string) (*spec.VersionedSignedBeaconBlock, error) {
	ret := _m.Called(ctx, blockID)

	if len(ret) == 0 {
		panic("no return value specified for SignedBeaconBlock")
	}

	var r0 *spec.VersionedSignedBeaconBlock
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string) (*spec.VersionedSignedBeaconBlock, error)); ok {
		return rf(ctx, blockID)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string) *spec.VersionedSignedBeaconBlock); ok {
		r0 = rf(ctx, blockID)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*spec.VersionedSignedBeaconBlock)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = rf(ctx, blockID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Spec provides a mock function with given fields: ctx
func (_m *Client) Spec(ctx context.Context) (map[string]interface{}, error) {
	ret := _m.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for Spec")
	}

	var r0 map[string]interface{}
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context) (map[string]interface{}, error)); ok {
		return rf(ctx)
	}
	if rf, ok := ret.Get(0).(func(context.Context) map[string]interface{}); ok {
		r0 = rf(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(map[string]interface{})
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = rf(ctx)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// SubmitAggregateAttestations provides a mock function with given fields: ctx, aggregateAndProofs
func (_m *Client) SubmitAggregateAttestations(ctx context.Context, aggregateAndProofs []*phase0.SignedAggregateAndProof) error {
	ret := _m.Called(ctx, aggregateAndProofs)

	if len(ret) == 0 {
		panic("no return value specified for SubmitAggregateAttestations")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, []*phase0.SignedAggregateAndProof) error); ok {
		r0 = rf(ctx, aggregateAndProofs)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// SubmitAttestations provides a mock function with given fields: ctx, attestations
func (_m *Client) SubmitAttestations(ctx context.Context, attestations []*phase0.Attestation) error {
	ret := _m.Called(ctx, attestations)

	if len(ret) == 0 {
		panic("no return value specified for SubmitAttestations")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, []*phase0.Attestation) error); ok {
		r0 = rf(ctx, attestations)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// SubmitBeaconBlock provides a mock function with given fields: ctx, block
func (_m *Client) SubmitBeaconBlock(ctx context.Context, block *spec.VersionedSignedBeaconBlock) error {
	ret := _m.Called(ctx, block)

	if len(ret) == 0 {
		panic("no return value specified for SubmitBeaconBlock")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, *spec.VersionedSignedBeaconBlock) error); ok {
		r0 = rf(ctx, block)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// SubmitBeaconCommitteeSubscriptions provides a mock function with given fields: ctx, subscriptions
func (_m *Client) SubmitBeaconCommitteeSubscriptions(ctx context.Context, subscriptions []*v1.BeaconCommitteeSubscription) error {
	ret := _m.Called(ctx, subscriptions)

	if len(ret) == 0 {
		panic("no return value specified for SubmitBeaconCommitteeSubscriptions")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, []*v1.BeaconCommitteeSubscription) error); ok {
		r0 = rf(ctx, subscriptions)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// SubmitBlindedBeaconBlock provides a mock function with given fields: ctx, block
func (_m *Client) SubmitBlindedBeaconBlock(ctx context.Context, block *api.VersionedSignedBlindedBeaconBlock) error {
	ret := _m.Called(ctx, block)

	if len(ret) == 0 {
		panic("no return value specified for SubmitBlindedBeaconBlock")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, *api.VersionedSignedBlindedBeaconBlock) error); ok {
		r0 = rf(ctx, block)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// SubmitProposalPreparations provides a mock function with given fields: ctx, preparations
func (_m *Client) SubmitProposalPreparations(ctx context.Context, preparations []*v1.ProposalPreparation) error {
	ret := _m.Called(ctx, preparations)

	if len(ret) == 0 {
		panic("no return value specified for SubmitProposalPreparations")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, []*v1.ProposalPreparation) error); ok {
		r0 = rf(ctx, preparations)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// SubmitSyncCommitteeContributions provides a mock function with given fields: ctx, contributionAndProofs
func (_m *Client) SubmitSyncCommitteeContributions(ctx context.Context, contributionAndProofs []*altair.SignedContributionAndProof) error {
	ret := _m.Called(ctx, contributionAndProofs)

	if len(ret) == 0 {
		panic("no return value specified for SubmitSyncCommitteeContributions")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, []*altair.SignedContributionAndProof) error); ok {
		r0 = rf(ctx, contributionAndProofs)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// SubmitSyncCommitteeMessages provides a mock function with given fields: ctx, messages
func (_m *Client) SubmitSyncCommitteeMessages(ctx context.Context, messages []*altair.SyncCommitteeMessage) error {
	ret := _m.Called(ctx, messages)

	if len(ret) == 0 {
		panic("no return value specified for SubmitSyncCommitteeMessages")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, []*altair.SyncCommitteeMessage) error); ok {
		r0 = rf(ctx, messages)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// SubmitSyncCommitteeSubscriptions provides a mock function with given fields: ctx, subscriptions
func (_m *Client) SubmitSyncCommitteeSubscriptions(ctx context.Context, subscriptions []*v1.SyncCommitteeSubscription) error {
	ret := _m.Called(ctx, subscriptions)

	if len(ret) == 0 {
		panic("no return value specified for SubmitSyncCommitteeSubscriptions")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, []*v1.SyncCommitteeSubscription) error); ok {
		r0 = rf(ctx, subscriptions)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// SubmitValidatorRegistrations provides a mock function with given fields: ctx, registrations
func (_m *Client) SubmitValidatorRegistrations(ctx context.Context, registrations []*api.VersionedSignedValidatorRegistration) error {
	ret := _m.Called(ctx, registrations)

	if len(ret) == 0 {
		panic("no return value specified for SubmitValidatorRegistrations")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, []*api.VersionedSignedValidatorRegistration) error); ok {
		r0 = rf(ctx, registrations)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// SyncCommitteeContribution provides a mock function with given fields: ctx, slot, subcommitteeIndex, beaconBlockRoot
func (_m *Client) SyncCommitteeContribution(ctx context.Context, slot phase0.Slot, subcommitteeIndex uint64, beaconBlockRoot phase0.Root) (*altair.SyncCommitteeContribution, error) {
	ret := _m.Called(ctx, slot, subcommitteeIndex, beaconBlockRoot)

	if len(ret) == 0 {
		panic("no return value specified for SyncCommitteeContribution")
	}

	var r0 *altair.SyncCommitteeContribution
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, phase0.Slot, uint64, phase0.Root) (*altair.SyncCommitteeContribution, error)); ok {
		return rf(ctx, slot, subcommitteeIndex, beaconBlockRoot)
	}
	if rf, ok := ret.Get(0).(func(context.Context, phase0.Slot, uint64, phase0.Root) *altair.SyncCommitteeContribution); ok {
		r0 = rf(ctx, slot, subcommitteeIndex, beaconBlockRoot)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*altair.SyncCommitteeContribution)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, phase0.Slot, uint64, phase0.Root) error); ok {
		r1 = rf(ctx, slot, subcommitteeIndex, beaconBlockRoot)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// SyncCommitteeDuties provides a mock function with given fields: ctx, epoch, indices
func (_m *Client) SyncCommitteeDuties(ctx context.Context, epoch phase0.Epoch, indices []phase0.ValidatorIndex) ([]*v1.SyncCommitteeDuty, error) {
	ret := _m.Called(ctx, epoch, indices)

	if len(ret) == 0 {
		panic("no return value specified for SyncCommitteeDuties")
	}

	var r0 []*v1.SyncCommitteeDuty
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, phase0.Epoch, []phase0.ValidatorIndex) ([]*v1.SyncCommitteeDuty, error)); ok {
		return rf(ctx, epoch, indices)
	}
	if rf, ok := ret.Get(0).(func(context.Context, phase0.Epoch, []phase0.ValidatorIndex) []*v1.SyncCommitteeDuty); ok {
		r0 = rf(ctx, epoch, indices)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]*v1.SyncCommitteeDuty)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, phase0.Epoch, []phase0.ValidatorIndex) error); ok {
		r1 = rf(ctx, epoch, indices)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Validators provides a mock function with given fields: ctx, stateID, indices
func (_m *Client) Validators(ctx context.Context, stateID string, indices []phase0.ValidatorIndex) (map[phase0.ValidatorIndex]*v1.Validator, error) {
	ret := _m.Called(ctx, stateID, indices)

	if len(ret) == 0 {
		panic("no return value specified for Validators")
	}

	var r0 map[phase0.ValidatorIndex]*v1.Validator
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, []phase0.ValidatorIndex) (map[phase0.ValidatorIndex]*v1.Validator, error)); ok {
		return rf(ctx, stateID, indices)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, []phase0.ValidatorIndex) map[phase0.ValidatorIndex]*v1.Validator); ok {
		r0 = rf(ctx, stateID, indices)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(map[phase0.ValidatorIndex]*v1.Validator)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, []phase0.ValidatorIndex) error); ok {
		r1 = rf(ctx, stateID, indices)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ValidatorsByPubKey provides a mock function with given fields: ctx, stateID, validatorPubKeys
func (_m *Client) ValidatorsByPubKey(ctx context.Context, stateID string, validatorPubKeys []phase0.BLSPubKey) (map[phase0.ValidatorIndex]*v1.Validator, error) {
	ret := _m.Called(ctx, stateID, validatorPubKeys)

	if len(ret) == 0 {
		panic("no return value specified for ValidatorsByPubKey")
	}

	var r0 map[phase0.ValidatorIndex]*v1.Validator
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, []phase0.BLSPubKey) (map[phase0.ValidatorIndex]*v1.Validator, error)); ok {
		return rf(ctx, stateID, validatorPubKeys)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, []phase0.BLSPubKey) map[phase0.ValidatorIndex]*v1.Validator); ok {
		r0 = rf(ctx, stateID, validatorPubKeys)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(map[phase0.ValidatorIndex]*v1.Validator)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, []phase0.BLSPubKey) error); ok {
		r1 = rf(ctx, stateID, validatorPubKeys)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// NewClient creates a new instance of Client. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewClient(t interface {
	mock.TestingT
	Cleanup(func())
}) *Client {
	mock := &Client{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
